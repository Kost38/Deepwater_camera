#!/usr/bin/python3

import asyncio # Lib for asynchronous programming
import threading # Lib for multithreaded programming 
import queue # Multithreaded queue

import tkinter # Tkinter lib for graphical interface
from tkinter import Frame # Frame - Tk themed widget set


from window_with_buttons import GUI # Class of the GUI window - form with buttons

import datetime
import time
import sys


# Global reference to loop allows access from different environments.
asyncio_running_loop: asyncio.AbstractEventLoop = None

#----------
# A multi-producer, multi-consumer queues for multithreaded programming 
# which implements internally all the required locking semantics

# Queue of commands generated by Tkinter for handling in asyncio service loop
tk_commands_queue: queue.Queue = queue.Queue()
# Queue of tasks generated by asyncio code for handling by Tkinter 
asyncio_tasks_queue: queue.Queue = queue.Queue()

#----------
# Time constants:

# Initial sleep time between iterations in asyncio service loop
asyncio_sleep_time = 0.01 # sec

# Delay after handling a command and task by the pair of queues (Tkinter + Asyncio)
min_time_between_commands =  0.1 # sec

# Time to wait before starting a next sequence of polling sensors
delay_after_chain_of_commands = 0.2 # sec

# Timeout of connection and sending packets for Async Modbus Client
modbus_timeout = 0.1


#----------
# Host address:

# Pressure sensor
#host_ip = "192.168.1.67" # old
host_ip = "10.0.10.167" # current
port_addr = "4001"
# Compass
#host_ip = "84.237.21.184" # old, external
#port_addr = "4001"
# Localhost
host_ip = "127.0.0.1"
port_addr = 10319


#----------
# Flag shows that a Tkinter command is in the queue
tk_commands_queue_is_busy = False
# Flag shows that a future task is sheduled and not done
tk_future_task_scheduled = False
# Python FAQ: "Assigning a value to a variable is an atomic operation in Python. 
# I.e. it is completed without interruption." (in the multithreaded environment)

# Stores the name of a Tkinter command which was added recently to the queue
last_tk_command_in_queue = ''



# Asyncio service loop (This runs in the special thread)
async def asyncio_service_loop(gui, aio_loop_shutdown_initiated: threading.Event):

    # Communicate the asyncio running loop status to tkinter via a global variable
    global asyncio_running_loop
    asyncio_running_loop = asyncio.get_running_loop()
    timed_msg('In a special thread: Got asyncio running loop: ' + str(asyncio_running_loop))
    
    global tk_commands_queue_is_busy    
    global tk_future_task_scheduled    
    tk_future_task_scheduled = False
    
    # Create an empty future
    tk_future_task = asyncio.Future() 
       
    timed_msg('In a special thread: Start iterations to keep asyncio event loop running...')
    while not aio_loop_shutdown_initiated.is_set():        
        asyncio_loop_wait_period = asyncio_sleep_time # Here time is in seconds
        
        if (tk_future_task_scheduled == False):
            try:     
                # Get a Tkinter command from the queue
                tk_command = tk_commands_queue.get_nowait()
            except queue.Empty:
                pass # Try next time
            else: # Got a Tkinter command from the queue
                tk_commands_queue_is_busy = False

                if (tk_command != 'Idle'):
                    # Create a future task to handle the Tkinter command asyncronously
                    tk_future_task = asyncio.ensure_future(gui.handle_command_in_asyncio_loop(tk_command))
                    # Set the flag
                    tk_future_task_scheduled = True
                else:
                    tk_commands_queue.queue.clear()
                    timed_msg('-AIO: Got "Idle" Tkinter command...')
                    

        if tk_future_task.done(): 
            try:
                # When the Tkinter command as a future task is done, save the result of it 
                # as a task from Asyncio for handling in Tkinter  
                asyncio_task = tk_future_task.result()
                # Put the task from Asyncio to the queue (don't use the thread-blocking 'put' method)
                asyncio_tasks_queue.put_nowait(asyncio_task)
            except queue.Full:
                pass # Try next time
            else:
                # Tkinter command as future task is done so set the flag
                tk_future_task_scheduled = False
                # Set Tkinter future task as Not done (by default for empty asyncio future constructor)
                tk_future_task = asyncio.Future()
                # Sleep some more before reading a new Tkinter command and sheduling a new Asyncio task...
                asyncio_loop_wait_period = min_time_between_commands

        # (The usual wait command - threading.Event.wait() - would block the current thread and the asyncio loop)
        await asyncio.sleep(asyncio_loop_wait_period)
        
    timed_msg('In a special thread: Asyncio service loop ended.')
    
def check_asyncio_event_loop_is_found():
    while not asyncio_running_loop:
        time.sleep(asyncio_sleep_time)
        timed_msg('Checking in Main Thread that Asyncio running loop is got...')

        
        
# Put a Tkinter command to the queue        
def put_tk_command_to_queue(tk_command, mainframe: Frame, fromWhere = 'a button click'):
    poll_interval = 50 # 0.05 s

    global tk_commands_queue_is_busy 
    global last_tk_command_in_queue
           
    # We should empty the tk_commands_queue and set 'not busy' flag before putting stopping commands
    if (tk_command == 'StopSensors' or tk_command == 'Disconnect' or tk_command == 'Idle'):       
        # Unless StopSensors was called from Disconnect button handling
        if (tk_command == 'Disconnect' and last_tk_command_in_queue == 'StopSensors' ): # and fromWhere == 'Disconnect handling'
            #timed_msg('-Not clear TK: "' + last_tk_command_in_queue + '" (before "' + tk_command + '" which came from ' + fromWhere + ')')
            pass
        else:  
            if (not tk_commands_queue.empty()):
                timed_msg('-Clear TK queue with: "' + last_tk_command_in_queue + '" (before "' + tk_command + '" which came from ' + fromWhere + ')')
                tk_commands_queue.queue.clear()
                tk_commands_queue_is_busy = False
                #print(list(tk_commands_queue.queue))
            else:
                #timed_msg('-Not clear TK(empty), Last: "' + last_tk_command_in_queue + '" (before "' + tk_command + '" which came from ' + fromWhere + ')')
                pass

    if (not tk_commands_queue.full() and not tk_commands_queue_is_busy and not tk_future_task_scheduled):    
        # Put a command from Tkinter to the queue (but don't wait). Asyncio can't wait for the thread-blocking 'put' method
        tk_commands_queue.put_nowait(tk_command) 
        timed_msg('-Put TK command: "' + tk_command + '" to queue from: ' + fromWhere)
        #print(list(tk_commands_queue.queue))
        
        last_tk_command_in_queue = tk_command
        tk_commands_queue_is_busy = True
    else:
        mainframe.after(poll_interval, lambda: put_tk_command_to_queue(tk_command, mainframe, fromWhere))
        
        
                
# Tkinter service loop (It runs in the Main Thread)
def tk_service_loop(mainframe: Frame, gui):
    #timed_msg('tk_future_task_scheduled: ' + str(tk_future_task_scheduled))

    # Poll continuously while queue has work to process.
    poll_interval =  10 # 0.01 s - Here time is in milliseconds
    if (tk_future_task_scheduled == False):
        try:
            # Get an Asyncio task from the queue for handling it in Tkinter (don't use the thread-blocking 'get' method)
            asyncio_task = asyncio_tasks_queue.get_nowait()            
        except queue.Empty:
            pass
        else: # Got Asyncio task
            # Handle the Asyncio task in Tkinter loop. Create a Tkinter command 
            # as a result of handling the task from Asyncio
            tk_command = gui.handle_task_in_tk_loop(asyncio_task)
            # Put the Tkinter command to the queue
            put_tk_command_to_queue(tk_command, mainframe, 'Asyncio task "' + asyncio_task[0] + '"')
            # Wait some more time before reading and handling a new task from asyncio
            poll_interval = int(min_time_between_commands * 1000)
    
    # Schedule a call of this function again in the tkinter event loop after the poll interval.
    mainframe.after(poll_interval, lambda: tk_service_loop(mainframe, gui))

   
# Set up working environments for asyncio and tkinter (This runs in the Main Thread)
def main():    
    # Create Tkinter
    tk_root = tkinter.Tk()
    mainframe = tkinter.Frame(tk_root)
    timed_msg('Tkinter created...' )
    
    # Create GUI interface in Tkinter
    gui = GUI(tk_root, mainframe, put_tk_command_to_queue, delay_after_chain_of_commands, modbus_timeout, host_ip, port_addr)
    timed_msg('GUI started...' )

    # Schedule the Tkinter service loop
    mainframe.after(0, lambda: tk_service_loop(mainframe, gui))
    timed_msg('Tkinter service loop started in the Main Thread...' )    
    
    # Event for signalling between threads (asyncio.Event() is not threadsafe)
    aio_loop_shutdown_initiated = threading.Event()
    
    # Define a function for running the asyncio service loop in a special thread
    def run_in_thread(aio_loop_shutdown_initiated: threading.Event):
        asyncio.run(asyncio_service_loop(gui, aio_loop_shutdown_initiated))
    
    # Start the asyncio event loop in a new thread (the asyncio thread)
    asyncio_loop_thread = threading.Thread(
        target=run_in_thread, 
        args=(aio_loop_shutdown_initiated,), 
        name="Asyncio's Thread")    
    asyncio_loop_thread.start()
    timed_msg("A special thread for Asyncio service loop is started...")        
    
    # The asyncio event loop must start before the tkinter main loop.
    check_asyncio_event_loop_is_found()
        
    timed_msg('Loop Tkinter main loop forever...' )   
    tk_root.mainloop()
    timed_msg('Tkinter main loop is finished.' )    
    
    aio_loop_shutdown_initiated.set()
    asyncio_loop_thread.join()    
    timed_msg("The thread of Asyncio service loop is joined.")

# Print timestamped messsage    
def timed_msg(msg: str):
    print(datetime.datetime.now().strftime('%H:%M:%S.%f')[:-3], msg)

if __name__ == '__main__':
    # Run main() with possible exception
    sys.exit(main())
 