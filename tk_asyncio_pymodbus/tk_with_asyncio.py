import asyncio # Lib for asynchronous programming
import threading # Lib for multithreaded programming 
import queue # Multithreaded queue

import tkinter as tk # Tkinter lib for graphical interface
import tkinter.ttk as ttk # Tk themed widget set


from window_with_buttons import GUI # Class of the GUI window

import datetime
import time
import sys

from typing import Optional



# Global reference to loop allows access from different environments.
asyncio_running_loop: Optional[asyncio.AbstractEventLoop] = None

#----------
# A multi-producer, multi-consumer queues for multithreaded programming 
# which implements internally all the required locking semantics

# Queue of data packages generated by Tkinter for handling in asyncio service loop
tk_gen_queue: queue.Queue = queue.Queue()
# Queue of data packages generated by asyncio code for handling by Tkinter 
asyncio_gen_queue: queue.Queue = queue.Queue()

# Sleep time between iterations in asyncio service loop
asyncio_loop_wait_period = 0.01 # sec

# When a task is finished the text one will be sent to a queue after this period of time
min_time_between_tasks = 0.4 # sec

# Time to wait before starting a next sequence of polling sensors
time_between_transactions = 0.01 # sec


# Pressure sensor
#host_ip = "192.168.1.67" 
host_ip = "10.0.10.167" # current
port_addr = "4001"
# Compass
#host_ip = "84.237.21.184" # old, external
#port_addr = "4001"
# Localhost
#host_ip = "127.0.0.1"
#port_addr = 10319


#----------
# Assigning a value to a variable is an atomic operation in Python. 
# I.e. it is completed without interruption. (Python FAQ.)

# Flag which shows that a future task is sheduled and not done
asyncio_future_scheduled = False
# Flag which shows that there are a Tkinter package is in the queue
tk_package_in_queue = False


# Asyncio permanent loop service (This runs in the special thread)
async def asyncio_service_loop(gui, aio_loop_shutdown_initiated: threading.Event):
    """ 
      Consume a package from the Tkinter queue (whose packages were generated in the Tkinter).
      Create a future task for handling it asyncronously.
      When done put the produced package (the result of the future task) 
      in the queue whose packages are from asyncio.
      Loop to a new iteration after a period of time.
    """   
    # Communicate the asyncio running loop status to tkinter via a global variable
    global asyncio_running_loop
    asyncio_running_loop = asyncio.get_running_loop()
    timed_msg('In a thread: Get asyncio running loop: ' + str(asyncio_running_loop))
    
    global tk_package_in_queue    
    global asyncio_future_scheduled
    asyncio_future_scheduled = False
    # Create an empty future
    asyncio_future = asyncio.Future() 
    
    timed_msg('Start iterations to keep asyncio event loop running...')
    while not aio_loop_shutdown_initiated.is_set():        
        asyncio_loop_wait_period = 0.01 # Here time is in seconds
        
        if (asyncio_future_scheduled == False):
            try:     
                # Consume Tkinter package
                tk_gen_package = tk_gen_queue.get_nowait()
            except queue.Empty:
                pass # Try next time
            else: # Got a Tkinter package
                if (tk_gen_package != 'Idle'):
                # Create a future task to handle Tkinter package
                    asyncio_future = asyncio.ensure_future(gui.handle_tk_gen_package_in_asyncio(tk_gen_package))
                    asyncio_future_scheduled = True
                else:
                   tk_package_in_queue = False 
                
        if asyncio_future.done(): 
            try:
                # Put a package to the asyncio generated queue (don't use the thread-blocking 'put' method)
                asyncio_gen_queue.put_nowait(asyncio_future.result())
            except queue.Full:
                pass # Try next time
            else:
                asyncio_future_scheduled = False
                tk_package_in_queue = False # Here the Tkinter package is fully handled
                asyncio_future = asyncio.Future()  
                # Sleep some more before reading a new tk generated package and sheduling a new asyncio task...
                asyncio_loop_wait_period = min_time_between_tasks
        
        # (The usual wait command - threading.Event.wait() - would block the current thread and the asyncio loop)
        await asyncio.sleep(asyncio_loop_wait_period)
        
    timed_msg('Asyncio loop service Exit...')
    
def check_asyncio_event_loop_is_found():
    while not asyncio_running_loop:
        time.sleep(asyncio_loop_wait_period)
        timed_msg('Waited for Asyncio event loop before starting Tkinter loop')
        
        
# Put a package to tkinter generated queue        
def put_to_tk_gen_queue(tk_gen_package, mainframe: ttk.Frame):
    poll_interval = 10 # 0.01 s
    
    global tk_package_in_queue            
    if (not tk_gen_queue.full()) and (not asyncio_future_scheduled) and (not tk_package_in_queue):
        # Put a work package to the queue (but don't wait). Asyncio can't wait for the thread-blocking 'put' method
        tk_gen_queue.put_nowait(tk_gen_package)  
        tk_package_in_queue = True
    else:
        mainframe.after(poll_interval, lambda: put_to_tk_gen_queue(tk_gen_package, mainframe))            

                
#  Start the Tkinter loop service. (It runs in the Main Thread.)
def tk_service_loop(mainframe: ttk.Frame, gui):
    """ 
      Consume a package from the queue whose packages were generated from asyncio. 
      If ok, call syncronously a handling function for the asyncio package.
      Put the produced package (the result of the handling function) in the queue with packages from Tkinter.
      Loop to a new iteration after a period of time.
      (After starting, it runs continuously until the GUI is closed by the user.)
    """    
    
    # Poll continuously while queue has work to process.
    poll_interval =  1 # 0.01 s - Here time is in milliseconds
    if (asyncio_future_scheduled == False):
        try:
            # Get a work package (but don't wait). Tkinter can't wait for the thread-blocking 'get' method...
            asyncio_gen_package = asyncio_gen_queue.get_nowait()                   
        except queue.Empty:
            pass
        else:
            # Handle a package from asyncio in tkinter. Put the result package from tkinter in tk_gen_queue.
            tk_gen_package = gui.handle_asyncio_gen_package_in_tk(asyncio_gen_package)
            put_to_tk_gen_queue(tk_gen_package, mainframe)
            # Wait some more time before reading and handling a new asyncio generated package
            poll_interval = int(min_time_between_tasks * 1000)
    
    # Schedule a call of this function again in the tkinter event loop after the poll interval.
    mainframe.after(poll_interval, lambda: tk_service_loop(mainframe, gui))

   
# Set up working environments for asyncio and tkinter (This runs in the Main Thread)
def main():    
    # Create Tkinter
    tk_root = tk.Tk()
    mainframe = ttk.Frame(tk_root)
    timed_msg('TK created...' )
    
    # Create GUI interface in Tkinter
    gui = GUI(tk_root, mainframe, put_to_tk_gen_queue, time_between_transactions, host_ip, port_addr)
    timed_msg('GUI started...' )

    # Schedule the work queue consumer loop in the tkinter event loop
    mainframe.after(0, lambda: tk_service_loop(mainframe, gui))
    timed_msg('Tkinter work queue loop started...' )    
    
    # Event for signalling between threads (asyncio.Event() is not threadsafe)
    aio_loop_shutdown_initiated = threading.Event()
    
    # Define a function for running the asyncio loop service in the asyncio thread
    def run_in_thread(aio_loop_shutdown_initiated: threading.Event):
        asyncio.run(asyncio_service_loop(gui, aio_loop_shutdown_initiated))
    
    # Start the asyncio event loop in a new thread (the asyncio thread)
    asyncio_loop_thread = threading.Thread(
        target=run_in_thread, 
        args=(aio_loop_shutdown_initiated,), 
        name="Asyncio's Thread")    
    asyncio_loop_thread.start()
    timed_msg("The thread for the asyncio event loop is started...")        
    
    # The asyncio event loop must start before the tkinter main loop.
    check_asyncio_event_loop_is_found()
    
    timed_msg('Start tkinter main loop...' )    
    tk_root.mainloop()
    timed_msg('Tkinter main loop is finished.' )    
    
    aio_loop_shutdown_initiated.set()
    timed_msg('Closing asyncio event loop...')
    asyncio_loop_thread.join()    
    timed_msg("Asyncio's loop thread is joined.")

# Print timestamped messsage    
def timed_msg(msg: str):
    print(datetime.datetime.now().strftime('%M:%S.%f')[:-3], msg)

if __name__ == '__main__':
    # Run main() with possible exception
    sys.exit(main())
 