import asyncio # Lib for asynchronous programming
import threading # Lib for multithreaded programming 
import queue # Multithreaded queue

import tkinter # Tkinter lib for graphical interface
from tkinter import Frame # Frame - Tk themed widget set


from window_with_buttons import GUI # Class of the GUI window

import datetime
import time
import sys

from typing import Optional



# Global reference to loop allows access from different environments.
asyncio_running_loop: Optional[asyncio.AbstractEventLoop] = None

#----------
# A multi-producer, multi-consumer queues for multithreaded programming 
# which implements internally all the required locking semantics

# Queue of data packages generated by Tkinter for handling in asyncio service loop
tk_gen_queue: queue.Queue = queue.Queue()
# Queue of data packages generated by asyncio code for handling by Tkinter 
asyncio_gen_queue: queue.Queue = queue.Queue()

# Sleep time between iterations in asyncio service loop
asyncio_loop_wait_period = 0.01 # sec

# When a task is finished the text one will be sent to a queue after this period of time
min_time_between_tasks =  0.1 # sec

# Time to wait before starting a next sequence of polling sensors
time_between_transactions = 0.2 # sec

# Timeout for connection and sending packets for Async Modbus Client
modbus_timeout = 0.1


# Pressure sensor
#host_ip = "192.168.1.67" # old
host_ip = "10.0.10.167" # current
port_addr = "4001"
# Compass
#host_ip = "84.237.21.184" # old, external
#port_addr = "4001"
# Localhost
#host_ip = "127.0.0.1"
#port_addr = 10319


#----------
# Assigning a value to a variable is an atomic operation in Python. 
# I.e. it is completed without interruption. (Python FAQ.)

# Flag which shows that a future task is sheduled and not done
asyncio_future_scheduled = False
# Flag which shows that there are a package from Tkinter in queue
package_from_tk_is_in_queue = False


# Asyncio permanent loop service (This runs in the special thread)
async def asyncio_service_loop(gui, aio_loop_shutdown_initiated: threading.Event):
    """ 
      Consume a package from Tkinter.
      Create a future task for handling it asyncronously.
      When done put the produced package (the result of the future task) in the specified queue.
      Loop to a new iteration after a period of time.
    """   
    # Communicate the asyncio running loop status to tkinter via a global variable
    global asyncio_running_loop
    asyncio_running_loop = asyncio.get_running_loop()
    timed_msg('In a thread: Get asyncio running loop: ' + str(asyncio_running_loop))
    
    global package_from_tk_is_in_queue    
    global asyncio_future_scheduled
    asyncio_future_scheduled = False
    # Create an empty future
    asyncio_future = asyncio.Future() 
    
    timed_msg('Start iterations to keep asyncio event loop running...')
    while not aio_loop_shutdown_initiated.is_set():        
        asyncio_loop_wait_period = 0.01 # Here time is in seconds
        
        if (asyncio_future_scheduled == False):
            try:     
                # Consume a package from Tkinter
                package_from_tk = tk_gen_queue.get_nowait()
            except queue.Empty:
                pass # Try next time
            else: # Got a package from Tkinter
                timed_msg('---Got a package from Tkinter: "' + package_from_tk + '" in Asyncio loop')
            
                if (package_from_tk != 'Idle'):
                # Create a future task to handle package from Tkinter
                    package_from_tk_is_in_queue = False 
                    asyncio_future = asyncio.ensure_future(gui.handle_package_in_asyncio_loop(package_from_tk))
                    asyncio_future_scheduled = True
                else:
                    package_from_tk_is_in_queue = False 
                    
                #timed_msg('package_from_tk_is_in_queue: ' + str(package_from_tk_is_in_queue))                    
                #timed_msg('asyncio_future_scheduled: ' + str(asyncio_future_scheduled))
                    

        if asyncio_future.done(): 
            try:
                # Put a package to the asyncio generated queue (don't use the thread-blocking 'put' method)
                asyncio_gen_queue.put_nowait(asyncio_future.result())
            except queue.Full:
                pass # Try next time
            else:
                asyncio_future_scheduled = False
                package_from_tk_is_in_queue = False # Here the Tkinter package is fully handled
                asyncio_future = asyncio.Future()  
                # Sleep some more before reading a new tkinter generated package and sheduling a new asyncio task...
                asyncio_loop_wait_period = min_time_between_tasks
                
                #timed_msg('-----asyncio_service_loop--fut done---: ')
                #timed_msg('package_from_tk_is_in_queue: ' + str(package_from_tk_is_in_queue))                    
                #timed_msg('asyncio_future_scheduled: ' + str(asyncio_future_scheduled))
        

        
        # (The usual wait command - threading.Event.wait() - would block the current thread and the asyncio loop)
        await asyncio.sleep(asyncio_loop_wait_period)
        
    timed_msg('Asyncio loop service Exit...')
    
def check_asyncio_event_loop_is_found():
    while not asyncio_running_loop:
        time.sleep(asyncio_loop_wait_period)
        timed_msg('Waited for Asyncio event loop before starting Tkinter loop')
        
        
# Put a package from tkinter to queue        
def put_package_from_tk_to_queue(package_from_tk, mainframe: Frame):
    poll_interval = 1000 #10 # 0.01 s

    global package_from_tk_is_in_queue  

    timed_msg('---Try to put a package from Tkinter: "' + package_from_tk + '" to queue')
    #timed_msg('asyncio_future_scheduled: ' + str(asyncio_future_scheduled))
    #timed_msg('package_from_tk_is_in_queue: ' + str(package_from_tk_is_in_queue))
    
    if (package_from_tk == 'StopSensors' or package_from_tk == 'Disconnect' or package_from_tk == 'Idle'):
        tk_gen_queue.queue.clear()
        package_from_tk_is_in_queue = False
              
    if (not tk_gen_queue.full()) and (not asyncio_future_scheduled) and (not package_from_tk_is_in_queue):
        # Put a package from tkinter to the queue (but don't wait). Asyncio can't wait for the thread-blocking 'put' method
        tk_gen_queue.put_nowait(package_from_tk)  
        package_from_tk_is_in_queue = True
        
        #timed_msg('package_from_tk_is_in_queue: ' + str(package_from_tk_is_in_queue))                    
        #timed_msg('asyncio_future_scheduled: ' + str(asyncio_future_scheduled))
    else:
        mainframe.after(poll_interval, lambda: put_package_from_tk_to_queue(package_from_tk, mainframe))            
        


                
#  Start the Tkinter loop service. (It runs in the Main Thread.)
def tk_service_loop(mainframe: Frame, gui):
    """ 
      Consume a package from the queue whose packages were generated from asyncio. 
      If ok, call syncronously a handling function for the asyncio package.
      Put the produced package (the result of the handling function) in the queue with packages from Tkinter.
      Loop to a new iteration after a period of time.
      (After starting, it runs continuously until the GUI is closed by the user.)
    """    
    
    # Poll continuously while queue has work to process.
    poll_interval =  1 # 0.01 s - Here time is in milliseconds
    if (asyncio_future_scheduled == False):
        try:
            # Get a package from asyncio (but don't wait). Tkinter can't wait for the thread-blocking 'get' method...
            package_from_asyncio = asyncio_gen_queue.get_nowait()                   
        except queue.Empty:
            pass
        else:
            timed_msg('---Got a package from Asyncio: "' + package_from_asyncio[0] + '" in Tkinter loop')
            #timed_msg('package_from_tk_is_in_queue: ' + str(package_from_tk_is_in_queue))                    
        
            # Handle a package from asyncio in tkinter. Put the result package from tkinter to tk_gen_queue.
            package_from_tk = gui.handle_package_in_tk_loop(package_from_asyncio)
            put_package_from_tk_to_queue(package_from_tk, mainframe)
            # Wait some more time before reading and handling a new package from asyncio
            poll_interval = int(min_time_between_tasks * 1000)
    
    # Schedule a call of this function again in the tkinter event loop after the poll interval.
    mainframe.after(poll_interval, lambda: tk_service_loop(mainframe, gui))

   
# Set up working environments for asyncio and tkinter (This runs in the Main Thread)
def main():    
    # Create Tkinter
    tk_root = tkinter.Tk()
    mainframe = Frame(tk_root)
    timed_msg('TK created...' )
    
    # Create GUI interface in Tkinter
    gui = GUI(tk_root, mainframe, put_package_from_tk_to_queue, time_between_transactions, modbus_timeout, host_ip, port_addr)
    timed_msg('GUI started...' )

    # Schedule the work queue consumer loop in the tkinter event loop
    mainframe.after(0, lambda: tk_service_loop(mainframe, gui))
    timed_msg('Tkinter work queue loop started...' )    
    
    # Event for signalling between threads (asyncio.Event() is not threadsafe)
    aio_loop_shutdown_initiated = threading.Event()
    
    # Define a function for running the asyncio loop service in the asyncio thread
    def run_in_thread(aio_loop_shutdown_initiated: threading.Event):
        asyncio.run(asyncio_service_loop(gui, aio_loop_shutdown_initiated))
    
    # Start the asyncio event loop in a new thread (the asyncio thread)
    asyncio_loop_thread = threading.Thread(
        target=run_in_thread, 
        args=(aio_loop_shutdown_initiated,), 
        name="Asyncio's Thread")    
    asyncio_loop_thread.start()
    timed_msg("The thread for the asyncio event loop is started...")        
    
    # The asyncio event loop must start before the tkinter main loop.
    check_asyncio_event_loop_is_found()
    
    timed_msg('Start tkinter main loop...' )    
    tk_root.mainloop()
    timed_msg('Tkinter main loop is finished.' )    
    
    aio_loop_shutdown_initiated.set()
    timed_msg('Closing asyncio event loop...')
    asyncio_loop_thread.join()    
    timed_msg("Asyncio's loop thread is joined.")

# Print timestamped messsage    
def timed_msg(msg: str):
    print(datetime.datetime.now().strftime('%M:%S.%f')[:-3], msg)

if __name__ == '__main__':
    # Run main() with possible exception
    sys.exit(main())
 